---
title: "San_Nic_Analysis"
author: "Owen Liu"
date: "March 29, 2016"
output: html_document
---

```{r data and required packages, echo=F}
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(reshape2)
library(vegan)
library(cluster)
library(gclus)
library(sp)
library(rgdal)

#note: all raw data has a .dat
W_D <- getwd()
# benthic cover raw data
cover.dat <- read.csv(file=paste(W_D,'/data/Benthic cover raw data.csv',sep=''))
# benthic species density
benthdens.dat <- read.csv(file=paste(W_D,'/data/Benthic density raw data.csv',sep=''))
#benthic fish density
fishdens.dat <- read.csv(file=paste(W_D,'/data/Benthic fish density raw data.csv',sep=''))
#midwater fish density
midwaterfish.dat <-  read.csv(file=paste(W_D,'/data/Midwater fish density raw data.csv',sep=''))
#spp key for the dataset
spp.key <- read.csv(file=paste(W_D,'/data/Table4_Species_sampled.csv',sep=''))

ott <- read.csv(file=paste(W_D,"/data/Table2_independent_sea_otters.csv",sep=""))
ott$Date<-as.Date(ott$Date,format="%m/%d/%Y")
plot(ott$Date,ott$West, main="Independent Sea Otters Observed at SNI",xlab="Year",ylab="Number of Otters",type="l",col="darkgreen",
     ylim=c(0,50),lwd=2)
lines(ott$Date,rowSums(cbind(ott$North,ott$South)),col="red",lwd=2)
lines(ott$Date,rowSums(cbind(ott$West,ott$North,ott$South)),lty="dotted",col="blue",lwd=2)
legend("topleft",col=c("darkgreen","red","blue"),legend=c("West","North and South","Total"),lty=1)

#fix dates in the datasets to be more readable by R
betterDates <-function(dat) {
  dates<-as.Date(as.character(dat$Date),format="%m/%d/%y")
  return(dates)
}
benthdens.dat$Date <- betterDates(benthdens.dat)
fishdens.dat$Date <- betterDates(fishdens.dat)
cover.dat$Date <- betterDates(cover.dat)
midwaterfish.dat$Date <- betterDates(midwaterfish.dat)

####helpful functions####
# Plot eigenvalues and percentages of variation of an ordination object
# Kaiser rule and broken stick model
# Usage:
# evplot(ev)
# where ev is a vector of eigenvalues

# License: GPL-2 
# Author: Francois Gillet, 25 August 2012

evplot <- function(ev)
{
  # Broken stick model (MacArthur 1957)
  n <- length(ev)
  bsm <- data.frame(j=seq(1:n), p=0)
  bsm$p[1] <- 1/n
  for (i in 2:n) bsm$p[i] <- bsm$p[i-1] + (1/(n + 1 - i))
  bsm$p <- 100*bsm$p/n
  # Plot eigenvalues and % of variation for each axis
  op <- par(mfrow=c(2,1))
  barplot(ev, main="Eigenvalues", col="bisque", las=2)
  abline(h=mean(ev), col="red")
  legend("topright", "Average eigenvalue", lwd=1, col=2, bty="n")
  barplot(t(cbind(100*ev/sum(ev), bsm$p[n:1])), beside=TRUE, 
          main="% variation", col=c("bisque",2), las=2)
  legend("topright", c("% eigenvalue", "Broken stick model"), 
         pch=15, col=c("bisque",2), bty="n")
  par(op)
}

## multiplot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# coldiss()
# Color plots of a dissimilarity matrix, without and with ordering
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012
# Usage:
# coldiss(D = dissimilarity.matrix, nc = 4, byrank = TRUE, diag = FALSE)
# If D is not a dissimilarity matrix (max(D) > 1), then D is divided by max(D)
# nc 							number of colours (classes)
# byrank= TRUE		equal-sized classes
# byrank= FALSE		equal-length intervals
# diag = TRUE			print object labels also on the diagonal

# Example:
# coldiss(spe.dj, nc=9, byrank=F, diag=T)
#
"coldiss" <- function(D, nc = 4, byrank = TRUE, diag = FALSE)
{
  require(gclus)
  
  if (max(D)>1) D <- D/max(D)
  
  if (byrank) {
    spe.color <- dmat.color(1-D, cm.colors(nc))
  }
  else {
    spe.color <- dmat.color(1-D, byrank=FALSE, cm.colors(nc))
  }
  
  spe.o <- order.single(1-D)
  speo.color <- spe.color[spe.o, spe.o]
  
  op <- par(mfrow=c(1,2), pty="s")
  
  if (diag) {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels)
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels[spe.o])
  }
  else {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix")
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix")
  }
  
  par(op)
}

# Function hcoplot()
# Reorder and plot dendrogram with colors for groups and legend
#
# Usage:
# hcoplot(tree = hclust.object, diss = dissimilarity.matrix, k = nb.clusters, 
#	title = paste("Reordered dendrogram from",deparse(tree$call),sep="\n"))
#
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012

"hcoplot" <- function(tree, diss, k, 
                      title=paste("Reordered dendrogram from", deparse(tree$call), sep="\n"))
{
  require(gclus)
  gr <- cutree(tree, k=k)
  tor <- reorder.hclust(tree, diss)
  plot(tor, hang=-1, xlab=paste(length(gr),"sites"), sub=paste(k,"clusters"), 
       main=title)
  so <- gr[tor$order]
  gro <- numeric(k)
  for (i in 1:k)
  {
    gro[i] <- so[1]
    if (i<k) so <- so[so!=gro[i]]
  }
  rect.hclust(tor, k=k, border=gro+1, cluster=gr)
  legend("topright", paste("Cluster",1:k), pch=22, col=2:(k+1), bty="n")
}
lunique <- function(x) length(unique(x))

#### end ####
```

Functions to look at density over time of certain taxa

```{r data viz functions}

#benthic cover species rank by mean % cover
spp.abun.cover<-arrange(aggregate(list(meancover=cover.dat$Cover),by=list(species=cover.dat$SpeciesCode),FUN=mean),
                        desc(meancover))

#function for a given species utilizing the benthic cover dataset
benthcover.spp.viz <- function (spp) {

  spp.dat <- subset(cover.dat,cover.dat$SpeciesCode==spp)
  #subset for the given species
  timeseries <- aggregate(list(Cover=spp.dat$Cover), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Cover,group=Site,color=Site)) + geom_line()
  return(list(tseries=timeseries,plot=spp.plot))
}

# and for density
spp.abun.benthdens<-arrange(aggregate(list(meandens=benthdens.dat$Density),by=list(species=benthdens.dat$SpeciesCode),FUN=mean), desc(meandens))

#add the species names for easier lookup later
spp.abun.benthdens<-merge(spp.abun.benthdens,spp.key[spp.key$DataSet=="Benthic density",-3],by.x="species",by.y="SpeciesCode")

#function for a given species utilizing the benthic density dataset
# can specify subset of stations you're interested in (default all stations)
benthdens.spp.viz <- function (spp,sites=1:7) {

  spp.dat <- subset(benthdens.dat,benthdens.dat$SpeciesCode==spp & benthdens.dat$Station %in% sites)
  #subset for the given species
  timeseries <- aggregate(list(Density=spp.dat$Density), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  tot <- aggregate(list(Density=spp.dat$Density), by=list(Period=spp.dat$Period),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Density,group=Site,color=Site)) + geom_line() + xlab("Year")+ylab("Density (ind./m2)")
  totplot <- ggplot(tot,aes(x=Period,y=Density)) + geom_line()
  
  #Returns total density by period, a timeseries plot broken up by site, and a plot of total mean density across sites
  return(list(tot=tot,tseries=timeseries,plot=spp.plot,totplot=totplot))
}

# Some interesting species
s_frans <- benthdens.spp.viz(29) # red urchins
s_purp <- benthdens.spp.viz(30) # purple urchins
patiria <- benthdens.spp.viz(24) # patiria miniata (bat star)
pisaster <- benthdens.spp.viz(92) # pisaster giganteus (giant sea star)

s_frans$plot + ggtitle("Red Urchin Density by Site Over Time")
s_frans$totplot + ggtitle("Mean Red Urchin Density Across All Sites")
s_purp$plot + ggtitle("Purple Urchin Density by Site Over Time")
s_purp$totplot + ggtitle("Mean Purple Urchin Density Across All Sites")
patiria$plot + ggtitle("Bat Star Density by Site Over Time")
patiria$totplot + ggtitle("Mean Bat Star Density Across All Sites")
pisaster$plot + ggtitle("Giant Sea Star Density by Site Over Time")
pisaster$totplot + ggtitle("Mean Giant Sea Star Density Across All Sites")

```

Diversity index for within-site/year 'samples'. Shannon-Weaver used.

```{r diversity function}
swdi <- function(dataset,site, period) { #dataset can be "benthdens","fish", or "midwater" (with quotes)
  #subset of data for given site/period
  set <- switch(dataset,
                "benthdens" = benthdens.dat,
                "fish" = fishdens.dat,
                "midwater" = midwaterfish.dat)
  
  dat <- subset(set,set$Station==site & set$Period==period)
  
  #if no data for that site/period combination, return N/A
  if(nrow(dat)==0) return(NA)
  
  #appropriate diveristy variable, depending on which dataset
  var <- switch(dataset,
                "benthdens"  = 'Density',
                "fish" = 'AdultDensity',
                "midwater" = 'AdultDensity')
  if(max(dat[,var])==0) return(NA)

  agg <- aggregate(list(density=dat[,var]),by=list(species=dat$SpeciesCode),FUN=mean)
  agg<-subset(agg,agg$density>0)
  
  # the index
  ind <- -sum(sapply(agg$density, function(x) x/sum(agg$density)*log(x/sum(agg$density))))
  return(ind)
}
```

```{r benthic density diversity over time}
#benthic density diversity over time, for all 7 Stations
benthdiv.site.datlist <- list()
benthdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(benthdens.dat$Period),function(x)
  mean(unique(benthdens.dat$Date[benthdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(benthdens.dat$Period),FUN=swdi,dataset='benthdens',site=i)
  out <- data.frame(period=unique(benthdens.dat$Period),diversity=series)
  out$date <- dates
  benthdiv.site.datlist[[t]] <- out
  benthdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=benthdiv.site.plotlist,cols=2)
```

```{r benthic fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
bfishdiv.site.datlist <- list()
bfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(fishdens.dat$Period),function(x)
  mean(unique(fishdens.dat$Date[fishdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(fishdens.dat$Period),FUN=swdi,dataset='fish',site=i)
  out <- data.frame(period=unique(fishdens.dat$Period),diversity=series)
  out$date <- dates
  bfishdiv.site.datlist[[t]] <- out
  bfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=bfishdiv.site.plotlist,cols=2)
```


```{r midwater fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
mfishdiv.site.datlist <- list()
mfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(midwaterfish.dat$Period),function(x)
  mean(unique(midwaterfish.dat$Date[midwaterfish.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(midwaterfish.dat$Period),FUN=swdi,dataset='midwater',site=i)
  out <- data.frame(period=unique(midwaterfish.dat$Period),diversity=series)
  out$date <- dates
  mfishdiv.site.datlist[[t]] <- out
  mfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Midwater Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=mfishdiv.site.plotlist,cols=2)
```


Let's do a cluster analysis.  There are a number of ways we could go about this, but let's start with looking at the clustering of sites, combining species abundance data from all years for each site.  Later, we can cluster years within the timeseries of each site.  We'll use the benthic fish data to start.

```{r site clusters based on species density}
#aggregate over years (i.e., aggregate density just by site and species, based on the fish data)
spe <- aggregate(list(dens=fishdens.dat$AdultDensity),by=list(station=fishdens.dat$Station,
                                                              species=fishdens.dat$SpeciesCode), FUN=mean) 
# "long form" data to "short form" matrix, where rows are stations (1-7), columns are species, and values are densities
spe <- acast(spe,station~species,value.var="dens")
spe<-as.data.frame(spe)

# Compute a chord distance matrix (i.e. differences between objects, or stations, based on relative species abundances)
spe.norm <- decostand(spe,'nor')
spe.dc <- dist(spe.norm)
#look quickly at a visual representation of the distance matrix
coldiss(spe.dc,byrank=FALSE,diag=TRUE)

## Clustering options ###
#Single Linkage Agglomerative Clustering
spe.ch.single <- hclust(spe.dc, method='single')
plot(spe.ch.single, main= 'Cluster - Single Linkage')

#Complete Linkage Agglomerative Clustering
spe.ch.complete <- hclust(spe.dc, method='complete')
plot(spe.ch.complete, main= 'Cluster - Complete Linkage')

#UPGMA (average distance) agglomerative clustering
spe.ch.UPGMA <- hclust(spe.dc,method='average')
plot(spe.ch.UPGMA, main= 'Cluster - UPGMA')

#centroid clustering
spe.ch.centroid <- hclust(spe.dc, method='centroid')
plot(spe.ch.centroid,main= 'Cluster - Centroid')

#Ward's minimum variance clustering
spe.ch.ward <- hclust(spe.dc, method='ward')
spe.ch.ward$height <- sqrt(spe.ch.ward$height)
plot(spe.ch.ward,main= 'Cluster - Ward')

## Cophenetic correlation for the above (trying to determine best clustering method) ##
# single linkage clustering
spe.ch.single.coph <- cophenetic(spe.ch.single)
cor(spe.dc,spe.ch.single.coph)
#complete linkage clustering
spe.ch.comp.coph <- cophenetic(spe.ch.complete)
cor(spe.dc,spe.ch.comp.coph)
#average clustering
spe.ch.UPGMA.coph <- cophenetic(spe.ch.UPGMA)
cor(spe.dc,spe.ch.UPGMA.coph)
#ward clustering
spe.ch.ward.coph <- cophenetic(spe.ch.ward)
cor(spe.dc,spe.ch.ward.coph)
#Shepard-like diagrams to illustrate the relationship between a distance matrix and a set of cophenetic matrices
par(mfrow=c(2,2))
plot(spe.dc,spe.ch.single.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.single.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

plot(spe.dc,spe.ch.comp.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Complete linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.comp.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.comp.coph),col='red')

plot(spe.dc,spe.ch.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('UPGMA', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.UPGMA.coph),col='red')

plot(spe.dc,spe.ch.ward.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Ward clustering', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.ward.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.ward.coph),col='red')

#Gower distance (another choice for determining best clustering)
gow.dist.single <- sum((spe.dc-spe.ch.single.coph)^2)
gow.dist.comp <- sum((spe.dc-spe.ch.comp.coph)^2)
gow.dist.UPGMA <- sum((spe.dc-spe.ch.UPGMA.coph)^2)
gow.dist.ward <- sum((spe.dc-spe.ch.ward.coph)^2)
gow.dist.single
gow.dist.comp
gow.dist.UPGMA
gow.dist.ward

#Graphs of fusion level values (where to cut the dendrogram?)
par(mfrow=c(2,2))
#Plot the fusion level values of the single linkage clustering
summary(spe.ch.single)
plot(spe.ch.single$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Single',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.single$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the complete linkage clustering
summary(spe.ch.complete)
plot(spe.ch.complete$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Complete',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.complete$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the UPGMA clustering
summary(spe.ch.UPGMA)
plot(spe.ch.UPGMA$height,nrow(spe):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.UPGMA$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the Ward clustering
summary(spe.ch.ward)
plot(spe.ch.ward$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Ward',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.ward$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

##Cut the trees to obtain k groups and compare the group contents using contingency tables

#choose a common number of groups
k<-3 #Number of groups where at least a small jump is present in all four graphs of fusion levels
#cut the dendrograms
spebc.single.g <- cutree(spe.ch.single,k)
spebc.complete.g <- cutree(spe.ch.complete,k)
spebc.UPGMA.g <- cutree(spe.ch.UPGMA,k)
spebc.ward.g <- cutree(spe.ch.ward,k)

#compare classifications by constructing contingency tables
#single vs. complete linkage
table(spebc.single.g,spebc.complete.g)
#single linkage vs. UPGMA
table(spebc.single.g,spebc.UPGMA.g)
#single linkage vs. Ward
table(spebc.single.g,spebc.ward.g)
#complete linkage vs. UPGMA
table(spebc.complete.g,spebc.UPGMA.g)
#complete linkage vs. Ward
table(spebc.complete.g,spebc.ward.g)
#UPGMA vs. Ward
table(spebc.UPGMA.g,spebc.ward.g)

# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(spe))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(spe)-1)) {
  sil <- silhouette(cutree(spe.ch.UPGMA,k=k),spe.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
par(mfrow=c(1,1))
plot(1:nrow(spe),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

## Optimal number of cluster according to Mantel statistic (Pearson)
# Function to compute a binary distance matrix from groups
grpdist <- function(X) {
  require(cluster)
  gr <- as.data.frame(as.factor(X))
  distgr <- daisy(gr,"gower")
  distgr
}

#Run based on UPGMA clustering
 kt <- data.frame(k=1:nrow(spe), r=0)
 
 for (i in 2:(nrow(spe)-1)) {
   gr<-cutree(spe.ch.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(spe.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=3 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-3
# Silhouette plot
cutg <- cutree(spe.ch.UPGMA,k=k)
sil <- silhouette(cutg,spe.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(spe)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=cutg+1,nmax.lab=100)

##Final dendrogram with the selected groups
# Reorder dendrogram from hclust(). reorder.hclust() reorders objects so that their order in the dissimilarity matrix
# is respected as much as possible. This does not affect the topology of the dendrogram
spe.ch.ord <- reorder.hclust(spe.ch.UPGMA,spe.dc)

#plot reordered dendrogram with group labels
plot(spe.ch.ord,hang=-1,xlab="3 groups",sub='',ylab='Height',main='Chord - UPGMA (reordered)', labels=cutree(spe.ch.ord,k=k))
rect.hclust(spe.ch.ord,k=k)

#plot the final dendrogram with group colors (RGBCMY)
hcoplot(spe.ch.UPGMA,spe.dc,k=3)


##Other representations of this final result
# Plot of the 4 UPGMA clusters on a map
# function to convert "deg min" to decimal degrees
dm2dd <- function(crd) {
  mins <- strsplit(as.character(crd),split=' ')
  mins <- as.numeric(unlist(mins))
  out <- ifelse(mins[1]>0, mins[1]+mins[2]/60, mins[1]-mins[2]/60)
  return(out)
}
stations.spa <- read.csv(file=paste(W_D,'/data/Table1_Monitoring_Stations.csv',sep=''))
names(stations.spa)<-c('station','name','lat','long','depth','date')

stations.spa$lat<-sapply(stations.spa$lat,dm2dd)
stations.spa$long<-sapply(stations.spa$long,dm2dd)

plot(stations.spa$long, stations.spa$lat,asp=1,type='n',main="Three UPGMA Groups",xlab='x coord',ylab='y coord')

#add the 3 groups
grw <- spebc.UPGMA.g
k <- length(levels(factor(grw)))
for(i in 1:k) {
  points(stations.spa[grw==i,4], stations.spa[grw==i,3], pch=i+20,cex=3,col=i-1,bg=i+1)
}
text(stations.spa$long, stations.spa$lat, stations.spa$station, cex=0.8, col='white',font=2)
legend('bottomright',paste('Group',1:k), pch=(1:k)+20,col=2:(k+1),pt.bg=2:(k+1),pt.cex=2,bty='n')

##Heat map of the distance matrix ordered with the dendrogram
dend <- as.dendrogram(spe.ch.ord)
heatmap(as.matrix(spe.dc), Rowv=dend,symm=TRUE,margin=c(3,3))
#Ordered community table
# species are ordered by the weighted averages on site scores
or <- vegemite(spe,spe.ch.ord,scale='log')
#and a heatmap for the doubly ordered community table
heatmap(t(spe[rev(or$species)]), Rowv=NA,Colv=dend,col=c('bisque',brewer.pal(3,'Greens')), scale='none',
        margin=c(4,4),ylab='Species (weighted averages of sites)',xlab='Sites')

## Three groups put Nav Fac by itself, as well as Sandy Cove, and group the West End, Dutch Harbor, and Daytona together.
```

The above cluster analysis was based on the adult fish found at each site.  What if we do the same for the benthic density dataset, which includes both benthic invertebrates and brown algae?
```{r site clusters based on benthic density}
#New spe dataset, using benthic density. Aggregate over years (i.e., aggregate density just by site and species, based on the benthic density data)
spe <- aggregate(list(dens=benthdens.dat$Density),by=list(station=benthdens.dat$Station,
                                                              species=benthdens.dat$SpeciesCode), FUN=mean) 
# "long form" data to "short form" matrix, where rows are stations (1-7), columns are species, and values are densities
spe <- acast(spe,station~species,value.var="dens")
spe<-as.data.frame(spe)

# Compute a chord distance matrix (i.e. differences between objects, or stations, based on relative species abundances )
spe.norm <- decostand(spe,'nor')
spe.dc <- dist(spe.norm)
#look quickly at a visual representation of the distance matrix
coldiss(spe.dc,byrank=FALSE,diag=TRUE)

## Clustering options ###
#Single Linkage Agglomerative Clustering
spe.ch.single <- hclust(spe.dc, method='single')
plot(spe.ch.single, main= 'Cluster - Single Linkage')

#Complete Linkage Agglomerative Clustering
spe.ch.complete <- hclust(spe.dc, method='complete')
plot(spe.ch.complete, main= 'Cluster - Complete Linkage')

#UPGMA (average distance) agglomerative clustering
spe.ch.UPGMA <- hclust(spe.dc,method='average')
plot(spe.ch.UPGMA, main= 'Cluster - UPGMA')

#centroid clustering
spe.ch.centroid <- hclust(spe.dc, method='centroid')
plot(spe.ch.centroid,main= 'Cluster - Centroid')

#Ward's minimum variance clustering
spe.ch.ward <- hclust(spe.dc, method='ward')
spe.ch.ward$height <- sqrt(spe.ch.ward$height)
plot(spe.ch.ward,main= 'Cluster - Ward')

## Cophenetic correlation for the above (trying to determine best clustering method) ##
# single linkage clustering
spe.ch.single.coph <- cophenetic(spe.ch.single)
cor(spe.dc,spe.ch.single.coph)
#complete linkage clustering
spe.ch.comp.coph <- cophenetic(spe.ch.complete)
cor(spe.dc,spe.ch.comp.coph)
#average clustering
spe.ch.UPGMA.coph <- cophenetic(spe.ch.UPGMA)
cor(spe.dc,spe.ch.UPGMA.coph)
#ward clustering
spe.ch.ward.coph <- cophenetic(spe.ch.ward)
cor(spe.dc,spe.ch.ward.coph)
#Shepard-like diagrams to illustrate the relationship between a distance matrix and a set of cophenetic matrices
par(mfrow=c(2,2))
plot(spe.dc,spe.ch.single.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,1),ylim=c(0,1),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.single.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

plot(spe.dc,spe.ch.comp.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,1),ylim=c(0,1),
     main=c('Complete linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.comp.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.comp.coph),col='red')

plot(spe.dc,spe.ch.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,1),ylim=c(0,1),
     main=c('UPGMA', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.UPGMA.coph),col='red')

plot(spe.dc,spe.ch.ward.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,1),ylim=c(0,1),
     main=c('Ward clustering', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.ward.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.ward.coph),col='red')

#Gower distance (another choice for determining best clustering)
gow.dist.single <- sum((spe.dc-spe.ch.single.coph)^2)
gow.dist.comp <- sum((spe.dc-spe.ch.comp.coph)^2)
gow.dist.UPGMA <- sum((spe.dc-spe.ch.UPGMA.coph)^2)
gow.dist.ward <- sum((spe.dc-spe.ch.ward.coph)^2)
gow.dist.single
gow.dist.comp
gow.dist.UPGMA
gow.dist.ward

#Graphs of fusion level values (where to cut the dendrogram?)
par(mfrow=c(2,2))
#Plot the fusion level values of the single linkage clustering
summary(spe.ch.single)
plot(spe.ch.single$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Single',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.single$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the complete linkage clustering
summary(spe.ch.complete)
plot(spe.ch.complete$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Complete',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.complete$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the UPGMA clustering
summary(spe.ch.UPGMA)
plot(spe.ch.UPGMA$height,nrow(spe):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.UPGMA$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the Ward clustering
summary(spe.ch.ward)
plot(spe.ch.ward$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Ward',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.ward$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

##Cut the trees to obtain k groups and compare the group contents using contingency tables

#choose a common number of groups
k<-3 #Number of groups where at least a small jump is present in all four graphs of fusion levels
#cut the dendrograms
spebc.single.g <- cutree(spe.ch.single,k)
spebc.complete.g <- cutree(spe.ch.complete,k)
spebc.UPGMA.g <- cutree(spe.ch.UPGMA,k)
spebc.ward.g <- cutree(spe.ch.ward,k)

#compare classifications by constructing contingency tables
#single vs. complete linkage
table(spebc.single.g,spebc.complete.g)
#single linkage vs. UPGMA
table(spebc.single.g,spebc.UPGMA.g)
#single linkage vs. Ward
table(spebc.single.g,spebc.ward.g)
#complete linkage vs. UPGMA
table(spebc.complete.g,spebc.UPGMA.g)
#complete linkage vs. Ward
table(spebc.complete.g,spebc.ward.g)
#UPGMA vs. Ward
table(spebc.UPGMA.g,spebc.ward.g)

# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(spe))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(spe)-1)) {
  sil <- silhouette(cutree(spe.ch.UPGMA,k=k),spe.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
par(mfrow=c(1,1))
plot(1:nrow(spe),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

## Optimal number of cluster according to Mantel statistic (Pearson)
# Function to compute a binary distance matrix from groups
grpdist <- function(X) {
  require(cluster)
  gr <- as.data.frame(as.factor(X))
  distgr <- daisy(gr,"gower")
  distgr
}

#Run based on UPGMA clustering
 kt <- data.frame(k=1:nrow(spe), r=0)
 
 for (i in 2:(nrow(spe)-1)) {
   gr<-cutree(spe.ch.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(spe.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=3 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-3
# Silhouette plot
cutg <- cutree(spe.ch.UPGMA,k=k)
sil <- silhouette(cutg,spe.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(spe)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=cutg+1,nmax.lab=100)

##Final dendrogram with the selected groups
# Reorder dendrogram from hclust(). reorder.hclust() reorders objects so that their order in the dissimilarity matrix
# is respected as much as possible. This does not affect the topology of the dendrogram
spe.ch.ord <- reorder.hclust(spe.ch.UPGMA,spe.dc)

#plot reordered dendrogram with group labels
plot(spe.ch.ord,hang=-1,xlab="3 groups",sub='',ylab='Height',main='Chord - UPGMA (reordered)', labels=cutree(spe.ch.ord,k=k))
rect.hclust(spe.ch.ord,k=k)

#plot the final dendrogram with group colors (RGBCMY)
hcoplot(spe.ch.UPGMA,spe.dc,k=3)


##Other representations of this final result
# Plot of the 4 UPGMA clusters on a map
# function to convert "deg min" to decimal degrees
dm2dd <- function(crd) {
  mins <- strsplit(as.character(crd),split=' ')
  mins <- as.numeric(unlist(mins))
  out <- ifelse(mins[1]>0, mins[1]+mins[2]/60, mins[1]-mins[2]/60)
  return(out)
}
stations.spa <- read.csv(file=paste(W_D,'/data/Table1_Monitoring_Stations.csv',sep=''))
names(stations.spa)<-c('station','name','lat','long','depth','date')

stations.spa$lat<-sapply(stations.spa$lat,dm2dd)
stations.spa$long<-sapply(stations.spa$long,dm2dd)

plot(stations.spa$long, stations.spa$lat,asp=1,type='n',main="Three UPGMA Groups",xlab='x coord',ylab='y coord')

#add the 3 groups
grw <- spebc.UPGMA.g
k <- length(levels(factor(grw)))
for(i in 1:k) {
  points(stations.spa[grw==i,4], stations.spa[grw==i,3], pch=i+20,cex=3,col=i-1,bg=i+1)
}
text(stations.spa$long, stations.spa$lat, stations.spa$station, cex=0.8, col='white',font=2)
legend('bottomright',paste('Group',1:k), pch=(1:k)+20,col=2:(k+1),pt.bg=2:(k+1),pt.cex=2,bty='n')

##Heat map of the distance matrix ordered with the dendrogram
dend <- as.dendrogram(spe.ch.ord)
heatmap(as.matrix(spe.dc), Rowv=dend,symm=TRUE,margin=c(3,3))
#Ordered community table
# species are ordered by the weighted averages on site scores
or <- vegemite(spe,spe.ch.ord,scale='log')
#and a heatmap for the doubly ordered community table
heatmap(t(spe[rev(or$species)]), Rowv=NA,Colv=dend,col=c('bisque',brewer.pal(3,'Greens')), scale='none',
        margin=c(4,4),ylab='Species (weighted averages of sites)',xlab='Sites')
```


I'm interested in potentially stable alternate phase states.  The classic alternate stable states in this context are urchins barrens vs. kelp forest. We can plot brown algal density vs. urchin density to see if there are distinct groups.

```{r phase state plots}
# red urchin density data
reds <- subset(benthdens.dat,SpeciesCode==29)
# aggregate by station
reds<-aggregate(list(dens=reds$Density),by=list(station=reds$Station,period=reds$Period),FUN=mean)

# purple urchin density data
purples <- subset(benthdens.dat, SpeciesCode==30)
# aggregate by station
purples<-aggregate(list(dens=purples$Density),by=list(station=purples$Station,period=purples$Period),FUN=mean)

# Macrocystis
mp<-subset(benthdens.dat,SpeciesCode==589)
mp <- aggregate(list(dens=mp$Density),by=list(station=mp$Station, period=mp$Period),FUN=mean)

# Laminaria
lam <-subset(benthdens.dat,SpeciesCode==556)
lam <- aggregate(list(dens=lam$Density),by=list(station=lam$Station, period=lam$Period),FUN=mean)

# Cystoseira
cysto <-subset(benthdens.dat,SpeciesCode==553)
cysto <- aggregate(list(dens=cysto$Density),by=list(station=cysto$Station, period=cysto$Period),FUN=mean)

# Eisenia
eis <-subset(benthdens.dat,SpeciesCode==574)
eis <- aggregate(list(dens=eis$Density),by=list(station=eis$Station, period=eis$Period),FUN=mean)


urch.mp <- left_join(reds,purples,by=c('station','period'))
names(urch.mp)[3]<-"red"
names(urch.mp)[4]<- "purple"
urch.mp <- left_join(urch.mp,mp,by=c('station','period'))
names(urch.mp)[5]<-"mp"
urch.mp <- left_join(urch.mp,lam,by=c('station','period'))
names(urch.mp)[6]<-"lam"
urch.mp <- left_join(urch.mp,cysto,by=c('station','period'))
names(urch.mp)[7]<-"cysto"
urch.mp <- left_join(urch.mp,eis,by=c('station','period'))
names(urch.mp)[8]<-"eis"

urch.mp.melt <- melt(urch.mp,id.vars=names(urch.mp)[1:2], measure.vars=names(urch.mp)[3:8])

# Red urchins vs. M. pyrifera at different sites
ggplot(urch.mp, aes(x=mp, y=red)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of M. pyrifera vs. S. franciscanus") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")

#With arrows (a "path" representation of change over time)
ggplot(urch.mp, aes(x=mp, y=red)) +geom_path(aes(col=period), arrow=arrow(type="closed",length=unit(0.05,"inches"))) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of M. pyrifera vs. S. franciscanus") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")

# Individual stations
urch.mp.7 <- subset(urch.mp,urch.mp$station==7)
urch.mp.2 <- subset(urch.mp,urch.mp$station==2)
urch.mp.3 <- subset(urch.mp,urch.mp$station==3)

#Station 7 Sandy Cove
ggplot(data=urch.mp.7, aes(x=mp, y=red)) +geom_point(aes(col=period),size=4)+geom_segment(aes(xend=c(tail(mp, n=-1), NA), yend=c(tail(red, n=-1), NA)),arrow=arrow(angle=20,type="closed",length=unit(0.2,"cm"))) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=40) +ggtitle("Density of M. pyrifera vs. S. franciscanus, Sandy Cove") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")+geom_text(aes(label=period),nudge_x = 0.02,nudge_y=0.5,size=3)

#Station 2
ggplot(data=urch.mp.2, aes(x=mp, y=red)) +geom_point(aes(col=period),size=4)+geom_segment(aes(xend=c(tail(mp, n=-1), NA), yend=c(tail(red, n=-1), NA)),arrow=arrow(angle=20,type="closed",length=unit(0.2,"cm")),col="darkgreen") +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=40) +ggtitle("Density of M. pyrifera vs. S. franciscanus, West End 'Urchin'") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")+geom_text(aes(label=period),nudge_x=0.05,nudge_y=0.2,size=3)

#Station 3
ggplot(data=urch.mp.3, aes(x=mp, y=red)) +geom_point(aes(col=period),size=4)+geom_segment(aes(xend=c(tail(mp, n=-1), NA), yend=c(tail(red, n=-1), NA)),arrow=arrow(angle=20,type="closed",length=unit(0.2,"cm")),col="darkgreen") +scale_color_gradient2(low="red",high="blue",mid="lightyellow",midpoint=30) +ggtitle("Density of M. pyrifera vs. S. franciscanus, West End 'Kelp'") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")+geom_text(aes(label=period),nudge_x = 0.05,nudge_y=0.2,size=3)

# Station 3, Cystoseira
ggplot(data=urch.mp.3, aes(x=cysto, y=red)) +geom_point(aes(col=period),size=4)+geom_segment(aes(xend=c(tail(cysto, n=-1), NA), yend=c(tail(red, n=-1), NA)),arrow=arrow(angle=20,type="closed",length=unit(0.2,"cm")),col="darkgreen") +scale_color_gradient2(low="red",high="blue",mid="lightyellow",midpoint=30) +ggtitle("Density of Cystoseira vs. S. franciscanus, West End 'Kelp'") + xlab("Cystoseira density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")+geom_text(aes(label=period),nudge_x = 0.05,nudge_y=0.2,size=3)

# Station 3, Cystoseira vs. Macro
ggplot(data=urch.mp.3, aes(x=cysto, y=mp)) +geom_point(aes(col=period),size=4)+geom_segment(aes(xend=c(tail(cysto, n=-1), NA), yend=c(tail(mp, n=-1), NA)),arrow=arrow(angle=20,type="closed",length=unit(0.2,"cm")),col="darkgreen") +scale_color_gradient2(low="red",high="blue",mid="lightyellow",midpoint=30) +ggtitle("Density of Cystoseira vs. M. pyrifera, West End 'Kelp'") + xlab("Cystoseira density (ind. >1m/m2)") + ylab("M. pyrifera density (ind./m2)")+geom_text(aes(label=period),nudge_x = 0.05,nudge_y=0.2,size=3)


#Purple urchins vs. M. pyrifera at different sites
ggplot(urch.mp, aes(x=mp, y=purple)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of M. pyrifera vs. S. purpuratus") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. purpuratus density (ind./m2)")

#Purple urchins vs. Red urchins? at different sites
ggplot(urch.mp, aes(x=red, y=purple)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of S.franciscanus vs. S. purpuratus") + xlab("S. franciscanus density (ind./m2)") + ylab("S. purpuratus density (ind./m2)")

# Red urchins vs. laminaria
ggplot(urch.mp, aes(x=lam, y=red)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of Laminaria spp. vs. S. franciscanus") + xlab("Laminaria spp. density (ind./m2)") + ylab("S. franciscanus density (ind./m2)")

# Red urchins vs. cystoseira
ggplot(urch.mp, aes(x=cysto, y=red)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of Cystoseira osmundacea vs. S. franciscanus") + xlab("Cystoseira osmundacea density (ind./m2)") + ylab("S. franciscanus density (ind./m2)")

# Red urchins vs. eisenia
ggplot(urch.mp, aes(x=eis, y=red)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of Eisenia arborea vs. S. franciscanus") + xlab("Eisenia density (ind./m2)") + ylab("S. franciscanus density (ind./m2)")


# Map of stations.
dir_spatial <- paste0(W_D,"/spatial")
san_nic_base <- readOGR(dsn = path.expand(dir_spatial),layer="san_nic_clip_base")
stations.spa <- readOGR(dsn = path.expand(dir_spatial),layer="stations")
sta.coords<-as.data.frame(stations.spa@coords)
ggplot() + geom_polygon(data=san_nic_base,aes(x=long,y=lat), fill='green3',col='black')+
  geom_text(data=sta.coords,aes(x=coords.x1,y=coords.x2, label=row.names(sta.coords)))
```


Ordination of years within sites.  Before, we looked at sites across all years.  Now, let's look within individual sites, where the "objects" (rows, samples) are years, and the columns (variables) are the species.  This time, we'll use the benthic density data

```{r clustering and ordination of years by site}
#aggregate sites by period
sites <- aggregate(list(dens=benthdens.dat$Density),by=list(station=benthdens.dat$Station,period=benthdens.dat$Period,
                                                              species=benthdens.dat$SpeciesCode), FUN=mean)
sit.names <- unique(sites$station)

# Create datasets for each site, and cast to matrices of periodxspecies
for(i in sit.names) {
  dat.t <- subset(sites,sites$station==i) #subset of 'master' (long form)
  
  dat.t <- acast(dat.t,period~species,value.var="dens") # cast to matrix
  dat.t <- as.data.frame((dat.t))
  datname <- paste0("site",i)
  assign(datname,dat.t) # assign raw data to variable name "site'i'"
  
  dat.norm <- decostand(dat.t,"normalize") # Euclidean norm (object vectors (periods) normalized to length 1)
  dat.norm <- dist(dat.norm) # Chord distance matrix
  distname <- paste0(datname,".dc") # Name for distance matrix
  assign(distname,dat.norm) # assign distance matrix to variable name "site'i'.dc" (for "distance-chord")
  
  #split seasons
  dat.t.spring <- sites[sites$period%%2==0 & sites$station==i,] #even periods (spring)
  dat.t.spring <- acast(dat.t.spring,period~species,value.var="dens",fun.aggregate = mean) # cast to matrix
  dat.t.spring <- as.data.frame(dat.t.spring)
  dat.t.fall <- sites[sites$period%%2==1 & sites$station==i,] #odd periods (fall)
  dat.t.fall <- acast(dat.t.fall,period~species,value.var="dens",fun.aggregate = mean) # cast to matrix
  dat.t.fall <- as.data.frame(dat.t.fall)
  datname.spring <-paste0(datname,".spring")
  datname.fall <-paste0(datname,".fall")
  assign(datname.spring,dat.t.spring) # assign raw spring data to variable name
  assign(datname.fall,dat.t.fall) # assign raw fall data to variable name
}

# Let's start with Site 7, and compute a clustering result (using UPGMA) and an ordination (correspondence)
dev.off()
site7.UPGMA <- hclust(site7.dc,method="average")
plot(site7.UPGMA, main="Clusters - UPGMA")

#cophenetic comparison to chord distance and shepard diagram
site7.UPGMA.coph <- cophenetic(site7.UPGMA)
cor(site7.dc,site7.UPGMA.coph)

plot(site7.dc,site7.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(site7.dc,site7.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

#Plot the fusion level values of the UPGMA clustering
plot(site7.UPGMA$height,nrow(site7):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(site7.UPGMA$height,nrow(site7):2,nrow(site7):2, col='red',cex=0.8)

## How many clusters (groups?)
# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(site7))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(site7)-1)) {
  sil <- silhouette(cutree(site7.UPGMA,k=k),site7.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
par(mfrow=c(1,1))
plot(1:nrow(site7),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

#Mantel statistic on UPGMA clustering
 kt <- data.frame(k=1:nrow(site7), r=0)
 
 for (i in 2:(nrow(site7)-1)) {
   gr<-cutree(site7.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(site7.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=4 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-2
# Silhouette plot
cutg <- cutree(site7.UPGMA,k=k)
sil <- silhouette(cutg,site7.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(site7)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=silo+1,nmax.lab=100)

# CA on Site 7 raw species dataset
# **********************************
# Compute CA
site7.ca <- cca(site7)
site7.ca
summary(site7.ca) # scaling 2 means chi-sq distance preserved between species
summary(site7.ca, scaling=1) # scaling 1 means chi-sq distance preserved between objects (periods)

# Plot eigenvalues and % of variance for each CA axis
(site7.ev<-site7.ca$CA$eig)
evplot(site7.ev)

## CA biplots
# ********************
par(mfrow=c(1,2))

#scaling 1: periods are centroids of species
plot(site7.ca,scaling=1,main="CA of benthic densities - biplot scaling 1")
#scaling 2: species are centroids of periods
plot(site7.ca,scaling=2,main="CA of benthic densities - biplot scaling 2")

## CA plus clustering result

# extraction of groups
site7.UPGMA.groups <- cutree(site7.UPGMA,k=2)
grp.lev <- levels(factor(site7.UPGMA.groups))

# Combination with CA
sit.sc <- scores(site7.ca,display="wa",scaling=1)
spe.ca.sc <- scores(site7.ca,display="sp",scaling=1)
site7.ca.p1 <-plot(site7.ca, display=c("wa","sp"),scaling=1, type="n", main="CA + clusters UPGMA/Chord")
for(i in 1:length(grp.lev)) points(sit.sc[site7.UPGMA.groups==i,],pch=(14+i), cex=2, col=i+1)
text(sit.sc,row.names(site7),pos=4,cex=0.7,col="blue")

# Adding species names for easier interpretation
# Scaling 1
site7.spe <- data.frame(spenum=as.numeric(names(site7)))
site7.spe<-merge(site7.spe,spp.key[spp.key$DataSet=="Benthic density",],by.x="spenum",by.y="SpeciesCode",all=F)
text(spe.ca.sc,as.character(site7.spe$SpeciesName),pos=4,cex=0.7)

# Scaling 2
sit.sc <- scores(site7.ca,display="wa",scaling=2)
spe.ca.sc <- scores(site7.ca,display="sp",scaling=2)
site7.ca.p2 <-plot(site7.ca, display=c("wa","sp"),scaling=2, type="n", main="CA + clusters UPGMA/Chord")
for(i in 1:length(grp.lev)) points(sit.sc[site7.UPGMA.groups==i,],pch=(14+i), cex=2, col=i+1)
text(sit.sc,row.names(site7),pos=4,cex=0.7,col="blue")

text(spe.ca.sc,as.character(site7.spe$SpeciesName),pos=4,cex=0.7)

```

CA for Sites 2 and 3, West End San Nic

```{r clustering and ordination of years by site for sites 2 and 3}
# **********************************
# Compute CA
site2.ca <- cca(site2)
site2.ca
summary(site2.ca) # scaling 2 means chi-sq distance preserved between species
summary(site2.ca, scaling=1) # scaling 1 means chi-sq distance preserved between objects (periods)

# Plot eigenvalues and % of variance for each CA axis
(site2.ev<-site2.ca$CA$eig)
evplot(site7.ev)

## CA biplots
# ********************
par(mfrow=c(1,2))

#scaling 1: periods are centroids of species
plot(site2.ca,scaling=1,main="CA of benthic densities - biplot scaling 1")
#scaling 2: species are centroids of periods
plot(site2.ca,scaling=2,main="CA of benthic densities - biplot scaling 2")

sit.sc <- scores(site2.ca,display="wa",scaling=1)
spe.ca.sc <- scores(site2.ca,display="sp",scaling=1)
par(mfrow=c(1,1))
site2.ca.p1 <-plot(site2.ca, display=c("wa","sp"),scaling=1, type="n", main="CA, Site 2 Scaling 1")
text(sit.sc,row.names(site2),pos=4,cex=0.7,col="blue")

# Adding species names for easier interpretation
# Scaling 1
site2.spe <- data.frame(spenum=as.numeric(names(site2)))
site2.spe<-merge(site2.spe,spp.key[spp.key$DataSet=="Benthic density",],by.x="spenum",by.y="SpeciesCode",all=F)
text(spe.ca.sc,as.character(site2.spe$SpeciesName),pos=4,cex=0.7)

# Scaling 2
sit.sc <- scores(site2.ca,display="wa",scaling=2)
spe.ca.sc <- scores(site2.ca,display="sp",scaling=2)
site2.ca.p2 <-plot(site2.ca, display=c("wa","sp"),scaling=2, type="n", main="CA, Site 2 Scaling 2")
for(i in 1:length(grp.lev)) points(sit.sc[site2.UPGMA.groups==i,],pch=(14+i), cex=2, col=i+1)
text(sit.sc,row.names(site2),pos=4,cex=0.7,col="blue")

text(spe.ca.sc,as.character(site2.spe$SpeciesName),pos=4,cex=0.7)

### Site 3
# Compute CA
site3.ca <- cca(site3)
site3.ca
summary(site3.ca) # scaling 2 means chi-sq distance preserved between species
summary(site3.ca, scaling=1) # scaling 1 means chi-sq distance preserved between objects (periods)

# Plot eigenvalues and % of variance for each CA axis
(site3.ev<-site3.ca$CA$eig)
evplot(site7.ev)

## CA biplots
# ********************
par(mfrow=c(1,2))

#scaling 1: periods are centroids of species
plot(site3.ca,scaling=1,main="CA of benthic densities - biplot scaling 1")
#scaling 2: species are centroids of periods
plot(site3.ca,scaling=2,main="CA of benthic densities - biplot scaling 2")

sit.sc <- scores(site3.ca,display="wa",scaling=1)
spe.ca.sc <- scores(site3.ca,display="sp",scaling=1)
par(mfrow=c(1,1))
site3.ca.p1 <-plot(site3.ca, display=c("wa","sp"),scaling=1, type="n", main="CA, Site 3 Scaling 1")
text(sit.sc,row.names(site3),pos=4,cex=0.7,col="blue")

# Adding species names for easier interpretation
# Scaling 1
site3.spe <- data.frame(spenum=as.numeric(names(site3)))
site3.spe<-merge(site3.spe,spp.key[spp.key$DataSet=="Benthic density",],by.x="spenum",by.y="SpeciesCode",all=F)
text(spe.ca.sc,as.character(site3.spe$SpeciesName),pos=4,cex=0.7)

# Scaling 2
sit.sc <- scores(site3.ca,display="wa",scaling=2)
spe.ca.sc <- scores(site3.ca,display="sp",scaling=2)
site3.ca.p2 <-plot(site3.ca, display=c("wa","sp"),scaling=2, type="n", main="CA, Site 3 Scaling 2")
text(sit.sc,row.names(site3),pos=4,cex=0.7,col="blue")

text(spe.ca.sc,as.character(site3.spe$SpeciesName),pos=4,cex=0.7)

```

General function for graphing a nice CA result for any of the sites (ordinating periods within a given site)

```{r general CA result graph function}
CA.ggplot <- function(site.dat, scaling=1,choices=c(1,2),plottitle=NULL) { #inputs are a site's dataset, and scaling 1 (default) or 2
  # Compute CA
  site.ca <- cca(site.dat)
  
  # Extract scores for plotting
  sit.sc <- as.data.frame(scores(site.ca,choices=choices,display="wa",scaling=scaling))
  sit.sc["period"]<-row.names(sit.sc)
  spe.ca.sc <- as.data.frame(scores(site.ca,choices=choices,display="sp",scaling=scaling))
  spe.ca.sc["species"]<-as.numeric(row.names(spe.ca.sc))
  
  # Adding species names for easier interpretation
  spe.ca.sc["spename"]<-left_join(spe.ca.sc,spp.key[spp.key$DataSet=="Benthic density",],by=c("species"="SpeciesCode"))$SpeciesName
  
  axes.names <- names(sit.sc)
  
  # The plot
  cols <- c("Periods"="blue","Species"="red")
  site.ca.p <-ggplot(spe.ca.sc) +
    geom_text(data=spe.ca.sc,aes_(x=as.name(axes.names[1]),y=as.name(axes.names[2]),label=as.name(names(spe.ca.sc[4]))),family="serif",col="red",size=3)+
    geom_text(data=sit.sc,aes_(x=as.name(axes.names[1]),y=as.name(axes.names[2]),label=as.name(names(sit.sc[3]))),col="blue") +
    geom_hline(yintercept=0,linetype=2)+ geom_vline(xintercept=0,linetype=2) +
    ggtitle(plottitle)
  
  return(site.ca.p)
}

# Remove seasonal variation by looking at odd periods (fall) and even periods (spring) separately
CA.ggplot(site2) + ggtitle("Correspondence Analysis, West End (Site 2)")

```

Logistic regression of phase state by otter density

```{r logistic regression}
# First, coerce data into "kelp forest" or "urchin barren" (binary)
# pooling data from sites 2,3, and 7
ott.state.bin <- subset(sites,sites$station %in% c(2,3,7)) #subset of 'master' (long form)
ott.state.bin <- dcast(ott.state.bin,period~species,value.var="dens",fun.aggregate = mean) # cast to data frame
ott.state.bin <- ott.state.bin[,c("period","29","589")]

# Have to manually match otter counts to periods, and assume population statis between periods when otters weren't counted
ott.counts <- c(rep(0,27),rep(10,3),9,rep(13,4),18,rep(20,3),24,22,20,20,30,29,29,29,29,31,31,34,30,34,42)
ott.state.bin$ott.count <- ott.counts
ott.state.bin$red.binary <- NA

# Criteria (somewhat arbitrary...)
# Barren = density of red urchins > 2/m2 AND macrocystis < 0.5/m2
# Kelp Forest = density of red urchins < 2/m2 AND macrocystis > 0.5/m2
ott.state.bin$red.binary <- apply(ott.state.bin,MARGIN=1,function(x){
  out<-NA
  if(x["29"]>2 & x["589"]<0.5) out = 0
  if(x["29"]<2 & x["589"]>0.5) out = 1
  return(out)
  })

# Plot with logistic fit
ggplot(ott.state.bin,aes(x=ott.count,y=red.binary)) +
  geom_point() +
  ggtitle("Ecosystem State as a Function of Otter Abundance") +
  xlab("Otter Abundance, # ind.") +
  ylab("Ecosystem State") +
  scale_y_continuous(breaks=c(0,1),labels=c("Barren","Kelp Forest")) +
  geom_smooth(method="glm",method.args = list(family = "binomial"),se=F) +
  geom_vline(xintercept=19,col="red",linetype=2) +
  geom_text(aes(22,0.1,label = "19 Otters"),col="darkred")
