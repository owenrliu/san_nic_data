---
title: "San_Nic_Analysis"
author: "Owen Liu"
date: "March 29, 2016"
output: html_document
---

```{r data and required packages, echo=F}
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(reshape2)
library(vegan)
library(cluster)
library(gclus)
library(sp)
library(rgdal)

#note: all raw data has a .dat
W_D <- getwd()
# benthic cover raw data
cover.dat <- read.csv(file=paste(W_D,'/data/Benthic cover raw data.csv',sep=''))
# benthic species density
benthdens.dat <- read.csv(file=paste(W_D,'/data/Benthic density raw data.csv',sep=''))
#benthic fish density
fishdens.dat <- read.csv(file=paste(W_D,'/data/Benthic fish density raw data.csv',sep=''))
#midwater fish density
midwaterfish.dat <-  read.csv(file=paste(W_D,'/data/Midwater fish density raw data.csv',sep=''))
#spp key for the dataset
spp.key <- read.csv(file=paste(W_D,'/data/Table4_Species_sampled.csv',sep=''))

#fix dates in the datasets to be more readable by R
betterDates <-function(dat) {
  dates<-as.Date(as.character(dat$Date),format="%m/%d/%y")
  return(dates)
}
benthdens.dat$Date <- betterDates(benthdens.dat)
fishdens.dat$Date <- betterDates(fishdens.dat)
cover.dat$Date <- betterDates(cover.dat)
midwaterfish.dat$Date <- betterDates(midwaterfish.dat)

####helpful functions####
# Plot eigenvalues and percentages of variation of an ordination object
# Kaiser rule and broken stick model
# Usage:
# evplot(ev)
# where ev is a vector of eigenvalues

# License: GPL-2 
# Author: Francois Gillet, 25 August 2012

evplot <- function(ev)
{
  # Broken stick model (MacArthur 1957)
  n <- length(ev)
  bsm <- data.frame(j=seq(1:n), p=0)
  bsm$p[1] <- 1/n
  for (i in 2:n) bsm$p[i] <- bsm$p[i-1] + (1/(n + 1 - i))
  bsm$p <- 100*bsm$p/n
  # Plot eigenvalues and % of variation for each axis
  op <- par(mfrow=c(2,1))
  barplot(ev, main="Eigenvalues", col="bisque", las=2)
  abline(h=mean(ev), col="red")
  legend("topright", "Average eigenvalue", lwd=1, col=2, bty="n")
  barplot(t(cbind(100*ev/sum(ev), bsm$p[n:1])), beside=TRUE, 
          main="% variation", col=c("bisque",2), las=2)
  legend("topright", c("% eigenvalue", "Broken stick model"), 
         pch=15, col=c("bisque",2), bty="n")
  par(op)
}

## multiplot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# coldiss()
# Color plots of a dissimilarity matrix, without and with ordering
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012
# Usage:
# coldiss(D = dissimilarity.matrix, nc = 4, byrank = TRUE, diag = FALSE)
# If D is not a dissimilarity matrix (max(D) > 1), then D is divided by max(D)
# nc 							number of colours (classes)
# byrank= TRUE		equal-sized classes
# byrank= FALSE		equal-length intervals
# diag = TRUE			print object labels also on the diagonal

# Example:
# coldiss(spe.dj, nc=9, byrank=F, diag=T)
#
"coldiss" <- function(D, nc = 4, byrank = TRUE, diag = FALSE)
{
  require(gclus)
  
  if (max(D)>1) D <- D/max(D)
  
  if (byrank) {
    spe.color <- dmat.color(1-D, cm.colors(nc))
  }
  else {
    spe.color <- dmat.color(1-D, byrank=FALSE, cm.colors(nc))
  }
  
  spe.o <- order.single(1-D)
  speo.color <- spe.color[spe.o, spe.o]
  
  op <- par(mfrow=c(1,2), pty="s")
  
  if (diag) {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels)
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels[spe.o])
  }
  else {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix")
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix")
  }
  
  par(op)
}

# Function hcoplot()
# Reorder and plot dendrogram with colors for groups and legend
#
# Usage:
# hcoplot(tree = hclust.object, diss = dissimilarity.matrix, k = nb.clusters, 
#	title = paste("Reordered dendrogram from",deparse(tree$call),sep="\n"))
#
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012

"hcoplot" <- function(tree, diss, k, 
                      title=paste("Reordered dendrogram from", deparse(tree$call), sep="\n"))
{
  require(gclus)
  gr <- cutree(tree, k=k)
  tor <- reorder.hclust(tree, diss)
  plot(tor, hang=-1, xlab=paste(length(gr),"sites"), sub=paste(k,"clusters"), 
       main=title)
  so <- gr[tor$order]
  gro <- numeric(k)
  for (i in 1:k)
  {
    gro[i] <- so[1]
    if (i<k) so <- so[so!=gro[i]]
  }
  rect.hclust(tor, k=k, border=gro+1, cluster=gr)
  legend("topright", paste("Cluster",1:k), pch=22, col=2:(k+1), bty="n")
}
lunique <- function(x) length(unique(x))

#### end ####
```

Functions to look at density over time of certain taxa

```{r data viz functions}

#benthic cover species rank by mean % cover
spp.abun.cover<-arrange(aggregate(list(meancover=cover.dat$Cover),by=list(species=cover.dat$SpeciesCode),FUN=mean),
                        desc(meancover))

#function for a given species utilizing the benthic cover dataset
benthcover.spp.viz <- function (spp) {
  #INPUTS: spp is the species code (taken from the spp.key above), res is the resolution (site level (denoted 'Station') or quadrat level(denoted "Quadrat"))
  spp.dat <- subset(cover.dat,cover.dat$SpeciesCode==spp)
  #subset for the given species
  timeseries <- aggregate(list(Cover=spp.dat$Cover), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Cover,group=Site,color=Site)) + geom_line()
  return(list(tseries=timeseries,plot=spp.plot))
}

# and for density
spp.abun.benthdens<-arrange(aggregate(list(meancover=benthdens.dat$Density),by=list(species=benthdens.dat$SpeciesCode),FUN=mean), desc(meancover))

#function for a given species utilizing the benthic cover dataset
benthdens.spp.viz <- function (spp) {
  #INPUTS: spp is the species code (taken from the spp.key above), res is the resolution (site level (denoted 'Station') or swath level(denoted "Swath"))
  spp.dat <- subset(benthdens.dat,benthdens.dat$SpeciesCode==spp)
  #subset for the given species
  timeseries <- aggregate(list(Density=spp.dat$Density), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Density,group=Site,color=Site)) + geom_line()
  return(list(tseries=timeseries,plot=spp.plot))
}
```

Diversity index for within-site/year 'samples'. Shannon-Weaver used.

```{r diversity function}
swdi <- function(dataset,site, period) { #dataset can be "benthdens","fish", or "midwater" (with quotes)
  #subset of data for given site/period
  set <- switch(dataset,
                "benthdens" = benthdens.dat,
                "fish" = fishdens.dat,
                "midwater" = midwaterfish.dat)
  
  dat <- subset(set,set$Station==site & set$Period==period)
  
  #if no data for that site/period combination, return N/A
  if(nrow(dat)==0) return(NA)
  
  #appropriate diveristy variable, depending on which dataset
  var <- switch(dataset,
                "benthdens"  = 'Density',
                "fish" = 'AdultDensity',
                "midwater" = 'AdultDensity')
  if(max(dat[,var])==0) return(NA)

  agg <- aggregate(list(density=dat[,var]),by=list(species=dat$SpeciesCode),FUN=mean)
  agg<-subset(agg,agg$density>0)
  
  # the index
  ind <- -sum(sapply(agg$density, function(x) x/sum(agg$density)*log(x/sum(agg$density))))
  return(ind)
}
```

```{r benthic density diversity over time}
#benthic density diversity over time, for all 7 Stations
benthdiv.site.datlist <- list()
benthdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(benthdens.dat$Period),function(x)
  mean(unique(benthdens.dat$Date[benthdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(benthdens.dat$Period),FUN=swdi,dataset='benthdens',site=i)
  out <- data.frame(period=unique(benthdens.dat$Period),diversity=series)
  out$date <- dates
  benthdiv.site.datlist[[t]] <- out
  benthdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=benthdiv.site.plotlist,cols=2)
```

```{r benthic fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
bfishdiv.site.datlist <- list()
bfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(fishdens.dat$Period),function(x)
  mean(unique(fishdens.dat$Date[fishdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(fishdens.dat$Period),FUN=swdi,dataset='fish',site=i)
  out <- data.frame(period=unique(fishdens.dat$Period),diversity=series)
  out$date <- dates
  bfishdiv.site.datlist[[t]] <- out
  bfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=bfishdiv.site.plotlist,cols=2)
```


```{r midwater fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
mfishdiv.site.datlist <- list()
mfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(midwaterfish.dat$Period),function(x)
  mean(unique(midwaterfish.dat$Date[midwaterfish.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(midwaterfish.dat$Period),FUN=swdi,dataset='midwater',site=i)
  out <- data.frame(period=unique(midwaterfish.dat$Period),diversity=series)
  out$date <- dates
  mfishdiv.site.datlist[[t]] <- out
  mfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Midwater Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=mfishdiv.site.plotlist,cols=2)
```


Let's do a cluster analysis.  There are a number of ways we could go about this, but let's start with looking at the clustering of sites, combining species abundance data from all years for each site.  Later, we can cluster years within the timeseries of each site.  We'll use the benthic fish data to start.

```{r site clusters based on species density}
#aggregate over years (i.e., aggregate density just by site and species)
spe <- aggregate(list(dens=fishdens.dat$AdultDensity),by=list(station=fishdens.dat$Station,
                                                              species=fishdens.dat$SpeciesCode), FUN=mean) 
# "long form" data to "short form" matrix, where rows are stations (1-7), columns are species, and values are densities
spe <- acast(spe,station~species,value.var="dens")
spe<-as.data.frame(spe)

# Compute a chord distance matrix (i.e. differences between objects, or stations, based on )
spe.norm <- decostand(spe,'nor')
spe.dc <- dist(spe.norm)
#look quickly at a visual representation of the distance matrix
coldiss(spe.dc,byrank=FALSE,diag=TRUE)

## Clustering options ###
#Single Linkage Agglomerative Clustering
spe.ch.single <- hclust(spe.dc, method='single')
plot(spe.ch.single, main= 'Cluster - Single Linkage')

#Complete Linkage Agglomerative Clustering
spe.ch.complete <- hclust(spe.dc, method='complete')
plot(spe.ch.complete, main= 'Cluster - Complete Linkage')

#UPGMA (average distance) agglomerative clustering
spe.ch.UPGMA <- hclust(spe.dc,method='average')
plot(spe.ch.UPGMA, main= 'Cluster - UPGMA')

#centroid clustering
spe.ch.centroid <- hclust(spe.dc, method='centroid')
plot(spe.ch.centroid,main= 'Cluster - Centroid')

#Ward's minimum variance clustering
spe.ch.ward <- hclust(spe.dc, method='ward')
spe.ch.ward$height <- sqrt(spe.ch.ward$height)
plot(spe.ch.ward,main= 'Cluster - Ward')

## Cophenetic correlation for the above (trying to determine best clustering method) ##
# single linkage clustering
spe.ch.single.coph <- cophenetic(spe.ch.single)
cor(spe.dc,spe.ch.single.coph)
#complete linkage clustering
spe.ch.comp.coph <- cophenetic(spe.ch.complete)
cor(spe.dc,spe.ch.comp.coph)
#average clustering
spe.ch.UPGMA.coph <- cophenetic(spe.ch.UPGMA)
cor(spe.dc,spe.ch.UPGMA.coph)
#ward clustering
spe.ch.ward.coph <- cophenetic(spe.ch.ward)
cor(spe.dc,spe.ch.ward.coph)
#Shepard-like diagrams to illustrate the relationship between a distance matrix and a set of cophenetic matrices
par(mfrow=c(2,2))
plot(spe.dc,spe.ch.single.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.single.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

plot(spe.dc,spe.ch.comp.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Complete linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.comp.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.comp.coph),col='red')

plot(spe.dc,spe.ch.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('UPGMA', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.UPGMA.coph),col='red')

plot(spe.dc,spe.ch.ward.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Ward clustering', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.ward.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.ward.coph),col='red')

#Gower distance (another choice for determining best clustering)
gow.dist.single <- sum((spe.dc-spe.ch.single.coph)^2)
gow.dist.comp <- sum((spe.dc-spe.ch.comp.coph)^2)
gow.dist.UPGMA <- sum((spe.dc-spe.ch.UPGMA.coph)^2)
gow.dist.ward <- sum((spe.dc-spe.ch.ward.coph)^2)
gow.dist.single
gow.dist.comp
gow.dist.UPGMA
gow.dist.ward

#Graphs of fusion level values (where to cut the dendrogram?)
par(mfrow=c(2,2))
#Plot the fusion level values of the single linkage clustering
summary(spe.ch.single)
plot(spe.ch.single$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Single',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.single$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the complete linkage clustering
summary(spe.ch.complete)
plot(spe.ch.complete$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Complete',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.complete$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the UPGMA clustering
summary(spe.ch.UPGMA)
plot(spe.ch.UPGMA$height,nrow(spe):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.UPGMA$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the Ward clustering
summary(spe.ch.ward)
plot(spe.ch.ward$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Ward',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.ward$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

##Cut the trees to obtain k groups and compare the group contents using contingency tables

#choose a common number of groups
k<-3 #Number of groups where at least a small jump is present in all four graphs of fusion levels
#cut the dendrograms
spebc.single.g <- cutree(spe.ch.single,k)
spebc.complete.g <- cutree(spe.ch.complete,k)
spebc.UPGMA.g <- cutree(spe.ch.UPGMA,k)
spebc.ward.g <- cutree(spe.ch.ward,k)

#compare classifications by constructing contingency tables
#single vs. complete linkage
table(spebc.single.g,spebc.complete.g)
#single linkage vs. UPGMA
table(spebc.single.g,spebc.UPGMA.g)
#single linkage vs. Ward
table(spebc.single.g,spebc.ward.g)
#complete linkage vs. UPGMA
table(spebc.complete.g,spebc.UPGMA.g)
#complete linkage vs. Ward
table(spebc.complete.g,spebc.ward.g)
#UPGMA vs. Ward
table(spebc.UPGMA.g,spebc.ward.g)

# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(spe))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(spe)-1)) {
  sil <- silhouette(cutree(spe.ch.UPGMA,k=k),spe.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
par(mfrow=c(1,1))
plot(1:nrow(spe),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

## Optimal number of cluster according to Mantel statistic (Pearson)
# Function to compute a binary distance matrix from groups
grpdist <- function(X) {
  require(cluster)
  gr <- as.data.frame(as.factor(X))
  distgr <- daisy(gr,"gower")
  distgr
}

#Run based on UPGMA clustering
 kt <- data.frame(k=1:nrow(spe), r=0)
 
 for (i in 2:(nrow(spe)-1)) {
   gr<-cutree(spe.ch.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(spe.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=3 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-3
# Silhouette plot
cutg <- cutree(spe.ch.UPGMA,k=k)
sil <- silhouette(cutg,spe.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(spe)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=cutg+1,nmax.lab=100)

##Final dendrogram with the selected groups
# Reorder dendrogram from hclust(). reorder.hclust() reorders objects so that their order in the dissimilarity matrix
# is respected as much as possible. This does not affect the topology of the dendrogram
spe.ch.ord <- reorder.hclust(spe.ch.UPGMA,spe.dc)

#plot reordered dendrogram with group labels
plot(spe.ch.ord,hang=-1,xlab="3 groups",sub='',ylab='Height',main='Chord - UPGMA (reordered)', labels=cutree(spe.ch.ord,k=k))
rect.hclust(spe.ch.ord,k=k)

#plot the final dendrogram with group colors (RGBCMY)
hcoplot(spe.ch.UPGMA,spe.dc,k=3)


##Other representations of this final result
# Plot of the 4 UPGMA clusters on a map
# function to convert "deg min" to decimal degrees
dm2dd <- function(crd) {
  mins <- strsplit(as.character(crd),split=' ')
  mins <- as.numeric(unlist(mins))
  out <- ifelse(mins[1]>0, mins[1]+mins[2]/60, mins[1]-mins[2]/60)
  return(out)
}
stations.spa <- read.csv(file=paste(W_D,'/data/Table1_Monitoring_Stations.csv',sep=''))
names(stations.spa)<-c('station','name','lat','long','depth','date')

stations.spa$lat<-sapply(stations.spa$lat,dm2dd)
stations.spa$long<-sapply(stations.spa$long,dm2dd)

plot(stations.spa$long, stations.spa$lat,asp=1,type='n',main="Three UPGMA Groups",xlab='x coord',ylab='y coord')

#add the 3 groups
grw <- spebc.UPGMA.g
k <- length(levels(factor(grw)))
for(i in 1:k) {
  points(stations.spa[grw==i,4], stations.spa[grw==i,3], pch=i+20,cex=3,col=i-1,bg=i+1)
}
text(stations.spa$long, stations.spa$lat, stations.spa$station, cex=0.8, col='white',font=2)
legend('bottomright',paste('Group',1:k), pch=(1:k)+20,col=2:(k+1),pt.bg=2:(k+1),pt.cex=2,bty='n')

##Heat map of the distance matrix ordered with the dendrogram
dend <- as.dendrogram(spe.ch.ord)
heatmap(as.matrix(spe.dc), Rowv=dend,symm=TRUE,margin=c(3,3))
#Ordered community table
# species are ordered by the weighted averages on site scores
or <- vegemite(spe,spe.ch.ord,scale='log')
#and a heatmap for the doubly ordered community table
heatmap(t(spe[rev(or$species)]), Rowv=NA,Colv=dend,col=c('bisque',brewer.pal(3,'Greens')), scale='none',
        margin=c(4,4),ylab='Species (weighted averages of sites)',xlab='Sites')
```


I'm interested in potentially stable alternate phase states.  The classic alternate stable states in this context are urchins barrens vs. kelp forest. We can plot brown algal density vs. urchin density to see if there are distinct groups.

```{r phase state plots}
# red urchin density data
reds <- subset(benthdens.dat,SpeciesCode==29)
# aggregate by station
reds<-aggregate(list(dens=reds$Density),by=list(station=reds$Station,period=reds$Period),FUN=mean)

# purple urchin density data
purples <- subset(benthdens.dat, SpeciesCode==30)
# aggregate by station
purples<-aggregate(list(dens=purples$Density),by=list(station=purples$Station,period=purples$Period),FUN=mean)

mp<-subset(benthdens.dat,SpeciesCode==589)
mp <- aggregate(list(dens=mp$Density),by=list(station=mp$Station, period=mp$Period),FUN=mean)

urch.mp <- left_join(reds,purples,by=c('station','period'))
urch.mp <- left_join(urch.mp,mp,by=c('station','period'))
names(urch.mp)[3:5] <- c("red","purple","mp")

urch.mp.melt <- melt(urch.mp,id.vars=names(urch.mp)[1:2], measure.vars=names(urch.mp)[3:5])

# Red urchins vs. M. pyrifera at different sites
ggplot(urch.mp, aes(x=mp, y=red)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of M. pyrifera vs. S. franciscanus") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. franciscanus density (ind./m2)")
S
#Purple urchins vs. M. pyrifera at different sites
ggplot(urch.mp, aes(x=mp, y=purple)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of M. pyrifera vs. S. purpuratus") + xlab("M. pyrifera density (ind. >1m/m2)") + ylab("S. purpuratus density (ind./m2)")

#Purple urchins vs. Red urchins? at different sites
ggplot(urch.mp, aes(x=red, y=purple)) +geom_point(aes(col=period)) +scale_color_gradient2(low="red",high="blue",mid="white",midpoint=30)+facet_wrap(~station) + ggtitle("Density of S.franciscanus vs. S. purpuratus") + xlab("S. franciscanus density (ind./m2)") + ylab("S. purpuratus density (ind./m2)")


# Map of stations.
dir_spatial <- paste0(W_D,"/spatial")
san_nic_base <- readOGR(dsn = path.expand(dir_spatial),layer="san_nic_clip_base")
stations.spa <- readOGR(dsn = path.expand(dir_spatial),layer="stations")
sta.coords<-as.data.frame(stations.spa@coords)
ggplot() + geom_polygon(data=san_nic_base,aes(x=long,y=lat), fill='green3',col='black')+
  geom_text(data=sta.coords,aes(x=coords.x1,y=coords.x2, label=row.names(sta.coords)))
```


Ordination of years within sites.  Before, we looked at sites across all years.  Now, let's look within individual sites, where the "objects" (rows, samples) are years, and the columns (variables) are the species.  This time, we'll use the benthic density data

```{r clustering and ordination of years by site}
#aggregate sites by year
sites <- aggregate(list(dens=benthdens.dat$Density),by=list(station=benthdens.dat$Station,period=benthdens.dat$Period,
                                                              species=benthdens.dat$SpeciesCode), FUN=mean)
sit.names <- unique(sites$station)

# Create datasets for each site, and cast to matrices of periodxspecies
for(i in sit.names) {
  dat.t <- subset(sites,sites$station==i) #subset of 'master' (long form)
  dat.t <- acast(dat.t,period~species,value.var="dens") # cast to matrix
  dat.t <- as.data.frame((dat.t))
  datname <- paste0("site",i)
  assign(datname,dat.t) # assign raw data to variable name "site'i'"
  dat.norm <- decostand(dat.t,"normalize") # Euclidean norm (object vectors (periods) normalized to length 1)
  dat.norm <- dist(dat.norm) # Chord distance matrix
  distname <- paste0(datname,".dc") # Name for distance matrix
  assign(distname,dat.norm) # assign distance matrix to variable name "site'i'.dc" (for "distance-chord")
}

# Let's start with Site 7, and compute a clustering result (using UPGMA) and an ordination (correspondence)
dev.off()
site7.UPGMA <- hclust(site7.dc,method="average")
plot(site7.UPGMA, main="Clusters - UPGMA")

#cophenetic comparison to chord distance and shepard diagram
site7.UPGMA.coph <- cophenetic(site7.UPGMA)
cor(site7.dc,site7.UPGMA.coph)

plot(site7.dc,site7.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(site7.dc,site7.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

#Plot the fusion level values of the UPGMA clustering
plot(site7.UPGMA$height,nrow(site7):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(site7.UPGMA$height,nrow(site7):2,nrow(site7):2, col='red',cex=0.8)

## How many clusters (groups?)
# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(site7))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(site7)-1)) {
  sil <- silhouette(cutree(site7.UPGMA,k=k),site7.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
par(mfrow=c(1,1))
plot(1:nrow(site7),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

#Mantel statistic on UPGMA clustering
 kt <- data.frame(k=1:nrow(site7), r=0)
 
 for (i in 2:(nrow(site7)-1)) {
   gr<-cutree(site7.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(site7.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=4 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-2
# Silhouette plot
cutg <- cutree(site7.UPGMA,k=k)
sil <- silhouette(cutg,site7.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(site7)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=silo+1,nmax.lab=100)

# CA on Site 7 raw species dataset
# **********************************
# Compute CA
site7.ca <- cca(site7)
site7.ca
summary(site7.ca) # scaling 2 means chi-sq distance preserved between species
summary(site7.ca, scaling=1) # scaling 1 means chi-sq distance preserved between objects (periods)

# Plot eigenvalues and % of variance for each CA axis
(site7.ev<-site7.ca$CA$eig)
evplot(site7.ev)

## CA biplots
# ********************
par(mfrow=c(1,2))

#scaling 1: periods are centroids of species
plot(site7.ca,scaling=1,main="CA of benthic densities - biplot scaling 1")
#scaling 2: species are centroids of periods
plot(site7.ca,scaling=2,main="CA of benthic densities - biplot scaling 2")

## CA plus clustering result

# extraction of groups
site7.UPGMA.groups <- cutree(site7.UPGMA,k=2)
grp.lev <- levels(factor(site7.UPGMA.groups))

# Combination with CA
sit.sc <- scores(site7.ca,display="wa",scaling=1)
p <-plot(site7.ca, display="wa",scaling=1, type="n", main="CA + clusters UPGMA/Chord")
for(i in 1:length(grp.lev)) points(sit.sc[site7.UPGMA.groups==i,],pch=(14+i), cex=2, col=i+1)
text(sit.sc,row.names(site7),pos=4,cex=0.7)

#Add the dendrogram
ordicluster(p, site7.UPGMA,col="dark grey")
legend(locator(1), paste("Group",c(1:length(grp.lev))),pch=14+c(1:length(grp.lev)), col=1+c(1:length(grp.lev)), pt.cex=2)
```