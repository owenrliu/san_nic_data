---
title: "San_Nic_Analysis"
author: "Owen Liu"
date: "March 29, 2016"
output: html_document
---

```{r data and required packages, echo=F}
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(reshape2)
library(vegan)

#note: all raw data has a .dat
W_D <- getwd()
# benthic cover raw data
cover.dat <- read.csv(file=paste(W_D,'/data/Benthic cover raw data.csv',sep=''))
# benthic species density
benthdens.dat <- read.csv(file=paste(W_D,'/data/Benthic density raw data.csv',sep=''))
#benthic fish density
fishdens.dat <- read.csv(file=paste(W_D,'/data/Benthic fish density raw data.csv',sep=''))
#midwater fish density
midwaterfish.dat <-  read.csv(file=paste(W_D,'/data/Midwater fish density raw data.csv',sep=''))
#spp key for the dataset
spp.key <- read.csv(file=paste(W_D,'/data/Table4_Species_sampled.csv',sep=''))

#fix dates in the datasets to be more readable by R
betterDates <-function(dat) {
  dates<-as.Date(as.character(dat$Date),format="%m/%d/%y")
  return(dates)
}
benthdens.dat$Date <- betterDates(benthdens.dat)
fishdens.dat$Date <- betterDates(fishdens.dat)
cover.dat$Date <- betterDates(cover.dat)
midwaterfish.dat$Date <- betterDates(midwaterfish.dat)

####helpful functions####
## multiplot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# coldiss()
# Color plots of a dissimilarity matrix, without and with ordering
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012
# Usage:
# coldiss(D = dissimilarity.matrix, nc = 4, byrank = TRUE, diag = FALSE)
# If D is not a dissimilarity matrix (max(D) > 1), then D is divided by max(D)
# nc 							number of colours (classes)
# byrank= TRUE		equal-sized classes
# byrank= FALSE		equal-length intervals
# diag = TRUE			print object labels also on the diagonal

# Example:
# coldiss(spe.dj, nc=9, byrank=F, diag=T)
#
"coldiss" <- function(D, nc = 4, byrank = TRUE, diag = FALSE)
{
  require(gclus)
  
  if (max(D)>1) D <- D/max(D)
  
  if (byrank) {
    spe.color <- dmat.color(1-D, cm.colors(nc))
  }
  else {
    spe.color <- dmat.color(1-D, byrank=FALSE, cm.colors(nc))
  }
  
  spe.o <- order.single(1-D)
  speo.color <- spe.color[spe.o, spe.o]
  
  op <- par(mfrow=c(1,2), pty="s")
  
  if (diag) {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels)
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix", 
               dlabels=attributes(D)$Labels[spe.o])
  }
  else {
    plotcolors(spe.color, rlabels=attributes(D)$Labels, 
               main="Dissimilarity Matrix")
    plotcolors(speo.color, rlabels=attributes(D)$Labels[spe.o], 
               main="Ordered Dissimilarity Matrix")
  }
  
  par(op)
}

# Function hcoplot()
# Reorder and plot dendrogram with colors for groups and legend
#
# Usage:
# hcoplot(tree = hclust.object, diss = dissimilarity.matrix, k = nb.clusters, 
#	title = paste("Reordered dendrogram from",deparse(tree$call),sep="\n"))
#
# License: GPL-2 
# Author: Francois Gillet, 23 August 2012

"hcoplot" <- function(tree, diss, k, 
                      title=paste("Reordered dendrogram from", deparse(tree$call), sep="\n"))
{
  require(gclus)
  gr <- cutree(tree, k=k)
  tor <- reorder.hclust(tree, diss)
  plot(tor, hang=-1, xlab=paste(length(gr),"sites"), sub=paste(k,"clusters"), 
       main=title)
  so <- gr[tor$order]
  gro <- numeric(k)
  for (i in 1:k)
  {
    gro[i] <- so[1]
    if (i<k) so <- so[so!=gro[i]]
  }
  rect.hclust(tor, k=k, border=gro+1, cluster=gr)
  legend("topright", paste("Cluster",1:k), pch=22, col=2:(k+1), bty="n")
}
lunique <- function(x) length(unique(x))

#### end ####
```

Functions to look at density over time of certain taxa

```{r data viz functions}

#benthic cover species rank by mean % cover
spp.abun.cover<-arrange(aggregate(list(meancover=cover.dat$Cover),by=list(species=cover.dat$SpeciesCode),FUN=mean),
                        desc(meancover))

#function for a given species utilizing the benthic cover dataset
benthcover.spp.viz <- function (spp) {
  #INPUTS: spp is the species code (taken from the spp.key above), res is the resolution (site level (denoted 'Station') or quadrat level(denoted "Quadrat"))
  spp.dat <- subset(cover.dat,cover.dat$SpeciesCode==spp)
  #subset for the given species
  timeseries <- aggregate(list(Cover=spp.dat$Cover), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Cover,group=Site,color=Site)) + geom_line()
  return(list(tseries=timeseries,plot=spp.plot))
}

# and for density
spp.abun.benthdens<-arrange(aggregate(list(meancover=benthdens.dat$Density),by=list(species=benthdens.dat$SpeciesCode),FUN=mean), desc(meancover))

#function for a given species utilizing the benthic cover dataset
benthdens.spp.viz <- function (spp) {
  #INPUTS: spp is the species code (taken from the spp.key above), res is the resolution (site level (denoted 'Station') or swath level(denoted "Swath"))
  spp.dat <- subset(benthdens.dat,benthdens.dat$SpeciesCode==spp)
  #subset for the given species
  timeseries <- aggregate(list(Density=spp.dat$Density), by=list(Date=spp.dat$Date,Site=spp.dat$Station),FUN=mean)
  timeseries$Site <- as.factor(timeseries$Site)
  spp.plot <- ggplot(timeseries,aes(x=Date,y=Density,group=Site,color=Site)) + geom_line()
  return(list(tseries=timeseries,plot=spp.plot))
}
```

Diversity index for within-site/year 'samples'. Shannon-Weaver used.

```{r diversity function}
swdi <- function(dataset,site, period) { #dataset can be "benthdens","fish", or "midwater" (with quotes)
  #subset of data for given site/period
  set <- switch(dataset,
                "benthdens" = benthdens.dat,
                "fish" = fishdens.dat,
                "midwater" = midwaterfish.dat)
  
  dat <- subset(set,set$Station==site & set$Period==period)
  
  #if no data for that site/period combination, return N/A
  if(nrow(dat)==0) return(NA)
  
  #appropriate diveristy variable, depending on which dataset
  var <- switch(dataset,
                "benthdens"  = 'Density',
                "fish" = 'AdultDensity',
                "midwater" = 'AdultDensity')
  if(max(dat[,var])==0) return(NA)

  agg <- aggregate(list(density=dat[,var]),by=list(species=dat$SpeciesCode),FUN=mean)
  agg<-subset(agg,agg$density>0)
  
  # the index
  ind <- -sum(sapply(agg$density, function(x) x/sum(agg$density)*log(x/sum(agg$density))))
  return(ind)
}
```

```{r benthic density diversity over time}
#benthic density diversity over time, for all 7 Stations
benthdiv.site.datlist <- list()
benthdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(benthdens.dat$Period),function(x)
  mean(unique(benthdens.dat$Date[benthdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(benthdens.dat$Period),FUN=swdi,dataset='benthdens',site=i)
  out <- data.frame(period=unique(benthdens.dat$Period),diversity=series)
  out$date <- dates
  benthdiv.site.datlist[[t]] <- out
  benthdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=benthdiv.site.plotlist,cols=2)
```

```{r benthic fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
bfishdiv.site.datlist <- list()
bfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(fishdens.dat$Period),function(x)
  mean(unique(fishdens.dat$Date[fishdens.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(fishdens.dat$Period),FUN=swdi,dataset='fish',site=i)
  out <- data.frame(period=unique(fishdens.dat$Period),diversity=series)
  out$date <- dates
  bfishdiv.site.datlist[[t]] <- out
  bfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Benthic Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=bfishdiv.site.plotlist,cols=2)
```


```{r midwater fish density diversity over time}
#benthic density diversity over time, for all 7 Stations
mfishdiv.site.datlist <- list()
mfishdiv.site.plotlist <- list()

#Periods have multiple nearby dates associated with them, and we can consolidate those dates for each period for graphing purposes
dates <- as.Date(sapply(unique(midwaterfish.dat$Period),function(x)
  mean(unique(midwaterfish.dat$Date[midwaterfish.dat$Period==x]))),origin = "1970-01-01")

for(i in 1:7) {
  t <- paste('Station',i)
  series<-sapply(unique(midwaterfish.dat$Period),FUN=swdi,dataset='midwater',site=i)
  out <- data.frame(period=unique(midwaterfish.dat$Period),diversity=series)
  out$date <- dates
  mfishdiv.site.datlist[[t]] <- out
  mfishdiv.site.plotlist[[t]] <- ggplot(out, aes(x=date,y=diversity)) +geom_line() +ggtitle(paste(t,'Midwater Fish Diversity')) +xlab('Time')+ylab('S-W Diversity')
}
multiplot(plotlist=mfishdiv.site.plotlist,cols=2)
```


Let's do a cluster analysis.  There are a number of ways we could go about this, but let's start with looking looking at the clustering of sites, combining species abundance data from all years for each site.  Later, we can cluster years within the timeseries of each site.  We'll use the benthic fish data to start.

```{r site clusters based on species density}
#aggregate over years (i.e., aggregate density just by site and species)
spe <- aggregate(list(dens=fishdens.dat$AdultDensity),by=list(station=fishdens.dat$Station,
                                                              species=fishdens.dat$SpeciesCode), FUN=mean) 
# "long form" data to "short form" matrix, where rows are stations (1-7), columns are species, and values are densities
spe <- acast(spe,station~species,value.var="dens")

# Compute a chord distance matrix (i.e. differences between objects, or stations, based on )
spe.norm <- decostand(spe,'nor')
spe.dc <- dist(spe.norm)
#look quickly at a visual representation of the distance matrix
coldiss(spe.dc,byrank=FALSE,diag=TRUE)

## Clustering options ###
#Single Linkage Agglomerative Clustering
spe.ch.single <- hclust(spe.dc, method='single')
plot(spe.ch.single, main= 'Cluster - Single Linkage')

#Complete Linkage Agglomerative Clustering
spe.ch.complete <- hclust(spe.dc, method='complete')
plot(spe.ch.complete, main= 'Cluster - Complete Linkage')

#UPGMA (average distance) agglomerative clustering
spe.ch.UPGMA <- hclust(spe.dc,method='average')
plot(spe.ch.UPGMA, main= 'Cluster - UPGMA')

#centroid clustering
spe.ch.centroid <- hclust(spe.dc, method='centroid')
plot(spe.ch.centroid,main= 'Cluster - Centroid')

#Ward's minimum variance clustering
spe.ch.ward <- hclust(spe.dc, method='ward')
spe.ch.ward$height <- sqrt(spe.ch.ward$height)
plot(spe.ch.ward,main= 'Cluster - Ward')

## Cophenetic correlation for the above (trying to determine best clustering method) ##
# single linkage clustering
spe.ch.single.coph <- cophenetic(spe.ch.single)
cor(spe.dc,spe.ch.single.coph)
#complete linkage clustering
spe.ch.comp.coph <- cophenetic(spe.ch.complete)
cor(spe.dc,spe.ch.comp.coph)
#average clustering
spe.ch.UPGMA.coph <- cophenetic(spe.ch.UPGMA)
cor(spe.dc,spe.ch.UPGMA.coph)
#ward clustering
spe.ch.ward.coph <- cophenetic(spe.ch.ward)
cor(spe.dc,spe.ch.ward.coph)
#Shepard-like diagrams to illustrate the relationship between a distance matrix and a set of cophenetic matrices
par(mfrow=c(2,2))
plot(spe.dc,spe.ch.single.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Single linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.single.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.single.coph),col='red')

plot(spe.dc,spe.ch.comp.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Complete linkage', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.comp.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.comp.coph),col='red')

plot(spe.dc,spe.ch.UPGMA.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('UPGMA', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.UPGMA.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.UPGMA.coph),col='red')

plot(spe.dc,spe.ch.ward.coph,xlab='Chord Distance',ylab='Cophenetic Distance',asp=1,xlim=c(0,sqrt(2)),ylim=c(0,sqrt(2)),
     main=c('Ward clustering', paste('Cophenetic correlation',round(cor(spe.dc,spe.ch.ward.coph),3))))
abline(0,1)
lines(lowess(spe.dc,spe.ch.ward.coph),col='red')

#Gower distance (another choice for determining best clustering)
gow.dist.single <- sum((spe.dc-spe.ch.single.coph)^2)
gow.dist.comp <- sum((spe.dc-spe.ch.comp.coph)^2)
gow.dist.UPGMA <- sum((spe.dc-spe.ch.UPGMA.coph)^2)
gow.dist.ward <- sum((spe.dc-spe.ch.ward.coph)^2)
gow.dist.single
gow.dist.comp
gow.dist.UPGMA
gow.dist.ward

#Graphs of fusion level values (where to cut the dendrogram?)
par(mfrow=c(2,2))
#Plot the fusion level values of the single linkage clustering
summary(spe.ch.single)
plot(spe.ch.single$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Single',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.single$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the complete linkage clustering
summary(spe.ch.complete)
plot(spe.ch.complete$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Complete',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.complete$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the UPGMA clustering
summary(spe.ch.UPGMA)
plot(spe.ch.UPGMA$height,nrow(spe):2,type='S',main='Fusion levels - Chord - UPGMA',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.UPGMA$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

#Plot the fusion level values of the Ward clustering
summary(spe.ch.ward)
plot(spe.ch.ward$height,nrow(spe):2,type='S',main='Fusion levels - Chord - Ward',ylab='k (number of clusters)',
     xlab='h (node height)',col='grey')
text(spe.ch.ward$height,nrow(spe):2,nrow(spe):2, col='red',cex=0.8)

# Optimal number of clusters according to silhouette widths(Rousseeuw quality index)
# Plot average silhouette widths (using UPGMA clustering) for all partitions except for the trivial partition in a single group
# First, create empty vector in which the asw values will be written
asw <- numeric(nrow(spe))

#Retrieve and write the asw values into the vector
for (k in 2:(nrow(spe)-1)) {
  sil <- silhouette(cutree(spe.ch.UPGMA,k=k),spe.dc)
  asw[k] <- summary(sil)$avg.width
}

# Best (largest) silhouette width
k.best <- which.max(asw)

#the plot is produced by plot.silhouette
plot(1:nrow(spe),asw,type='h',main="Silhouette - optimal number of clusters, UPGMA",xlab='k (number of groups)',
     ylab="Average silhouette width")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(asw),pch=16,col='red',cex=1.5)

cat("", "Silhouette - Optimal number of clusters k =", k.best,'\n', "with an average silhouette width of", max(asw),"\n")

## Optimal number of cluster according to Mantel statistic (Pearson)
# Function to compute a binary distance matrix from groups
grpdist <- function(X) {
  require(cluster)
  gr <- as.data.frame(as.factor(X))
  distgr <- daisy(gr,"gower")
  distgr
}

#Run based on Ward clustering
 kt <- data.frame(k=1:nrow(spe), r=0)
 
 for (i in 2:(nrow(spe)-1)) {
   gr<-cutree(spe.ch.UPGMA,i)
   distgr <- grpdist(gr)
   mt <- cor(spe.dc,distgr,method="pearson")
   kt[i,2]<-mt
 }
 
kt
k.best <- which.max(kt$r)

plot(kt$k,kt$r,type='h',main='Mantel - optimal number of clusters - UPGMA',xlab='k (number of groups)',
    ylab="Pearson's correlation")
axis(1,k.best,paste('optimum',k.best,sep="\n"),col='red',font=2,col.axis='red')
points(k.best,max(kt$r),pch=16,col='red',cex=1.5)

## we choose k=3 as our final number of groups, and UPGMA clustering as our best-option dendrogram
# Silhouette plot of final partition
k<-3
# Silhouette plot
cutg <- cutree(spe.ch.UPGMA,k=k)
sil <- silhouette(cutg,spe.dc)
silo<- sortSilhouette(sil)
rownames(silo) <- row.names(spe)[attr(silo,'iOrd')]
plot(silo,main='Silhouette plot - Chord - Ward',cex.names=0.8,col=cutg+1,nmax.lab=100)
```